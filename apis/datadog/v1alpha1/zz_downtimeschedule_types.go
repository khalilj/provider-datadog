// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DowntimeScheduleInitParameters struct {

	// (String) The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone *string `json:"displayTimezone,omitempty" tf:"display_timezone,omitempty"`

	// (String) A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same @username notation as events.
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// (Block, Optional) (see below for nested schema)
	MonitorIdentifier *MonitorIdentifierInitParameters `json:"monitorIdentifier,omitempty" tf:"monitor_identifier,omitempty"`

	// (Boolean) If the first recovery notification during a downtime should be muted.
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification *bool `json:"muteFirstRecoveryNotification,omitempty" tf:"mute_first_recovery_notification,omitempty"`

	// (Set of String) States that will trigger a monitor notification when the notify_end_types action occurs.
	// States that will trigger a monitor notification when the `notify_end_types` action occurs.
	// +listType=set
	NotifyEndStates []*string `json:"notifyEndStates,omitempty" tf:"notify_end_states,omitempty"`

	// (Set of String) Actions that will trigger a monitor notification if the downtime is in the notify_end_types state.
	// Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
	// +listType=set
	NotifyEndTypes []*string `json:"notifyEndTypes,omitempty" tf:"notify_end_types,omitempty"`

	// (Block, Optional) (see below for nested schema)
	OneTimeSchedule *OneTimeScheduleInitParameters `json:"oneTimeSchedule,omitempty" tf:"one_time_schedule,omitempty"`

	// (Block, Optional) (see below for nested schema)
	RecurringSchedule *RecurringScheduleInitParameters `json:"recurringSchedule,omitempty" tf:"recurring_schedule,omitempty"`

	// (String) The scope to which the downtime applies. Must follow the common search syntax.
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type DowntimeScheduleObservation struct {

	// (String) The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone *string `json:"displayTimezone,omitempty" tf:"display_timezone,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same @username notation as events.
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// (Block, Optional) (see below for nested schema)
	MonitorIdentifier *MonitorIdentifierObservation `json:"monitorIdentifier,omitempty" tf:"monitor_identifier,omitempty"`

	// (Boolean) If the first recovery notification during a downtime should be muted.
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification *bool `json:"muteFirstRecoveryNotification,omitempty" tf:"mute_first_recovery_notification,omitempty"`

	// (Set of String) States that will trigger a monitor notification when the notify_end_types action occurs.
	// States that will trigger a monitor notification when the `notify_end_types` action occurs.
	// +listType=set
	NotifyEndStates []*string `json:"notifyEndStates,omitempty" tf:"notify_end_states,omitempty"`

	// (Set of String) Actions that will trigger a monitor notification if the downtime is in the notify_end_types state.
	// Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
	// +listType=set
	NotifyEndTypes []*string `json:"notifyEndTypes,omitempty" tf:"notify_end_types,omitempty"`

	// (Block, Optional) (see below for nested schema)
	OneTimeSchedule *OneTimeScheduleObservation `json:"oneTimeSchedule,omitempty" tf:"one_time_schedule,omitempty"`

	// (Block, Optional) (see below for nested schema)
	RecurringSchedule *RecurringScheduleObservation `json:"recurringSchedule,omitempty" tf:"recurring_schedule,omitempty"`

	// (String) The scope to which the downtime applies. Must follow the common search syntax.
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type DowntimeScheduleParameters struct {

	// (String) The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	// +kubebuilder:validation:Optional
	DisplayTimezone *string `json:"displayTimezone,omitempty" tf:"display_timezone,omitempty"`

	// (String) A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same @username notation as events.
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	// +kubebuilder:validation:Optional
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// (Block, Optional) (see below for nested schema)
	// +kubebuilder:validation:Optional
	MonitorIdentifier *MonitorIdentifierParameters `json:"monitorIdentifier,omitempty" tf:"monitor_identifier,omitempty"`

	// (Boolean) If the first recovery notification during a downtime should be muted.
	// If the first recovery notification during a downtime should be muted.
	// +kubebuilder:validation:Optional
	MuteFirstRecoveryNotification *bool `json:"muteFirstRecoveryNotification,omitempty" tf:"mute_first_recovery_notification,omitempty"`

	// (Set of String) States that will trigger a monitor notification when the notify_end_types action occurs.
	// States that will trigger a monitor notification when the `notify_end_types` action occurs.
	// +kubebuilder:validation:Optional
	// +listType=set
	NotifyEndStates []*string `json:"notifyEndStates,omitempty" tf:"notify_end_states,omitempty"`

	// (Set of String) Actions that will trigger a monitor notification if the downtime is in the notify_end_types state.
	// Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
	// +kubebuilder:validation:Optional
	// +listType=set
	NotifyEndTypes []*string `json:"notifyEndTypes,omitempty" tf:"notify_end_types,omitempty"`

	// (Block, Optional) (see below for nested schema)
	// +kubebuilder:validation:Optional
	OneTimeSchedule *OneTimeScheduleParameters `json:"oneTimeSchedule,omitempty" tf:"one_time_schedule,omitempty"`

	// (Block, Optional) (see below for nested schema)
	// +kubebuilder:validation:Optional
	RecurringSchedule *RecurringScheduleParameters `json:"recurringSchedule,omitempty" tf:"recurring_schedule,omitempty"`

	// (String) The scope to which the downtime applies. Must follow the common search syntax.
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type MonitorIdentifierInitParameters struct {

	// (Number) ID of the monitor to prevent notifications.
	// ID of the monitor to prevent notifications.
	MonitorID *float64 `json:"monitorId,omitempty" tf:"monitor_id,omitempty"`

	// (Set of String) A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match all provided monitor tags. Setting monitor_tags to [*] configures the downtime to mute all monitors for the given scope.
	// A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
	// +listType=set
	MonitorTags []*string `json:"monitorTags,omitempty" tf:"monitor_tags,omitempty"`
}

type MonitorIdentifierObservation struct {

	// (Number) ID of the monitor to prevent notifications.
	// ID of the monitor to prevent notifications.
	MonitorID *float64 `json:"monitorId,omitempty" tf:"monitor_id,omitempty"`

	// (Set of String) A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match all provided monitor tags. Setting monitor_tags to [*] configures the downtime to mute all monitors for the given scope.
	// A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
	// +listType=set
	MonitorTags []*string `json:"monitorTags,omitempty" tf:"monitor_tags,omitempty"`
}

type MonitorIdentifierParameters struct {

	// (Number) ID of the monitor to prevent notifications.
	// ID of the monitor to prevent notifications.
	// +kubebuilder:validation:Optional
	MonitorID *float64 `json:"monitorId,omitempty" tf:"monitor_id,omitempty"`

	// (Set of String) A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match all provided monitor tags. Setting monitor_tags to [*] configures the downtime to mute all monitors for the given scope.
	// A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
	// +kubebuilder:validation:Optional
	// +listType=set
	MonitorTags []*string `json:"monitorTags,omitempty" tf:"monitor_tags,omitempty"`
}

type OneTimeScheduleInitParameters struct {

	// 8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
	// ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
	End *string `json:"end,omitempty" tf:"end,omitempty"`

	// 8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	// ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	Start *string `json:"start,omitempty" tf:"start,omitempty"`
}

type OneTimeScheduleObservation struct {

	// 8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
	// ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
	End *string `json:"end,omitempty" tf:"end,omitempty"`

	// 8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	// ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	Start *string `json:"start,omitempty" tf:"start,omitempty"`
}

type OneTimeScheduleParameters struct {

	// 8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
	// ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
	// +kubebuilder:validation:Optional
	End *string `json:"end,omitempty" tf:"end,omitempty"`

	// 8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	// ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	// +kubebuilder:validation:Optional
	Start *string `json:"start,omitempty" tf:"start,omitempty"`
}

type RecurringScheduleInitParameters struct {

	// (Block List) (see below for nested schema)
	Recurrence []RecurringScheduleRecurrenceInitParameters `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// (String) The timezone in which to schedule the downtime.
	// The timezone in which to schedule the downtime.
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`
}

type RecurringScheduleObservation struct {

	// (Block List) (see below for nested schema)
	Recurrence []RecurringScheduleRecurrenceObservation `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// (String) The timezone in which to schedule the downtime.
	// The timezone in which to schedule the downtime.
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`
}

type RecurringScheduleParameters struct {

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Recurrence []RecurringScheduleRecurrenceParameters `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// (String) The timezone in which to schedule the downtime.
	// The timezone in which to schedule the downtime.
	// +kubebuilder:validation:Optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`
}

type RecurringScheduleRecurrenceInitParameters struct {

	// (String) The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
	// The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
	Duration *string `json:"duration,omitempty" tf:"duration,omitempty"`

	// (String) The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to rrule and set the FREQ to MONTHLY and BYMONTHDAY to 1. Most common rrule options from the iCalendar Spec are supported.  Note: Attributes specifying the duration in RRULE are not supported (for example, DTSTART, DTEND, DURATION). More examples available in this downtime guide.
	// The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
	Rrule *string `json:"rrule,omitempty" tf:"rrule,omitempty"`

	// 8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	// ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
	Start *string `json:"start,omitempty" tf:"start,omitempty"`
}

type RecurringScheduleRecurrenceObservation struct {

	// (String) The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
	// The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
	Duration *string `json:"duration,omitempty" tf:"duration,omitempty"`

	// (String) The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to rrule and set the FREQ to MONTHLY and BYMONTHDAY to 1. Most common rrule options from the iCalendar Spec are supported.  Note: Attributes specifying the duration in RRULE are not supported (for example, DTSTART, DTEND, DURATION). More examples available in this downtime guide.
	// The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
	Rrule *string `json:"rrule,omitempty" tf:"rrule,omitempty"`

	// 8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	// ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
	Start *string `json:"start,omitempty" tf:"start,omitempty"`
}

type RecurringScheduleRecurrenceParameters struct {

	// (String) The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
	// The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
	// +kubebuilder:validation:Optional
	Duration *string `json:"duration" tf:"duration,omitempty"`

	// (String) The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to rrule and set the FREQ to MONTHLY and BYMONTHDAY to 1. Most common rrule options from the iCalendar Spec are supported.  Note: Attributes specifying the duration in RRULE are not supported (for example, DTSTART, DTEND, DURATION). More examples available in this downtime guide.
	// The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
	// +kubebuilder:validation:Optional
	Rrule *string `json:"rrule" tf:"rrule,omitempty"`

	// 8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
	// ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
	// +kubebuilder:validation:Optional
	Start *string `json:"start,omitempty" tf:"start,omitempty"`
}

// DowntimeScheduleSpec defines the desired state of DowntimeSchedule
type DowntimeScheduleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DowntimeScheduleParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DowntimeScheduleInitParameters `json:"initProvider,omitempty"`
}

// DowntimeScheduleStatus defines the observed state of DowntimeSchedule.
type DowntimeScheduleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DowntimeScheduleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// DowntimeSchedule is the Schema for the DowntimeSchedules API. Provides a Datadog DowntimeSchedule resource. This can be used to create and manage Datadog downtimes.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,datadog}
type DowntimeSchedule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.recurringSchedule) || (has(self.initProvider) && has(self.initProvider.recurringSchedule))",message="spec.forProvider.recurringSchedule is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.scope) || (has(self.initProvider) && has(self.initProvider.scope))",message="spec.forProvider.scope is a required parameter"
	Spec   DowntimeScheduleSpec   `json:"spec"`
	Status DowntimeScheduleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DowntimeScheduleList contains a list of DowntimeSchedules
type DowntimeScheduleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DowntimeSchedule `json:"items"`
}

// Repository type metadata.
var (
	DowntimeSchedule_Kind             = "DowntimeSchedule"
	DowntimeSchedule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DowntimeSchedule_Kind}.String()
	DowntimeSchedule_KindAPIVersion   = DowntimeSchedule_Kind + "." + CRDGroupVersion.String()
	DowntimeSchedule_GroupVersionKind = CRDGroupVersion.WithKind(DowntimeSchedule_Kind)
)

func init() {
	SchemeBuilder.Register(&DowntimeSchedule{}, &DowntimeScheduleList{})
}
